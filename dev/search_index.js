var documenterSearchIndex = {"docs":
[{"location":"oxygen/#Oxygen-atoms","page":"Oxygen atoms","title":"Oxygen atoms","text":"","category":"section"},{"location":"oxygen/","page":"Oxygen atoms","title":"Oxygen atoms","text":"The Backbone type has a type parameter N to represent the number of atoms per residue allowing one to pass only the N, CA, and C atoms of a backbone, such that the O atom positions can added in using the add_oxygens function.","category":"page"},{"location":"oxygen/","page":"Oxygen atoms","title":"Oxygen atoms","text":"julia> using Backboner\n\njulia> protein = pdb_to_protein(\"test/data/1ZAK.pdb\")\n2-element Vector{ProteinChain}:\n ProteinChain A with 220 residues\n ProteinChain B with 220 residues\n\njulia> chain = protein[\"A\"]\nProteinChain A with 220 residues\n\njulia> backbone4 = chain.backbone\n3×4×220 Backbone{4, Float32}:\n[:, :, 1] =\n 22.346  22.901  23.227  22.689\n 17.547  18.031  16.793  15.72\n 23.294  21.993  21.163  21.448\n\n;;; … \n\n[:, :, 220] =\n 21.808  22.263  21.085  19.939\n 13.861  13.862  14.233  13.851\n  2.734   1.355   0.446   0.791\n\njulia> backbone3 = remove_column(backbone4, 4) # remove oxygen column\n3×3×220 Backbone{3, Float32}:\n[:, :, 1] =\n 22.346  22.901  23.227\n 17.547  18.031  16.793\n 23.294  21.993  21.163\n\n;;; … \n\n[:, :, 220] =\n 21.808  22.263  21.085\n 13.861  13.862  14.233\n  2.734   1.355   0.446\n\njulia> backbone4_approx = add_oxygens(backbone3) # add oxygen column\n3×4×220 Backbone{4, Float32}:\n[:, :, 1] =\n 22.346  22.901  23.227  22.6697\n 17.547  18.031  16.793  15.7257\n 23.294  21.993  21.163  21.4295\n\n;;; … \n\n[:, :, 220] =\n 21.808  22.263  21.085  20.2198\n 13.861  13.862  14.233  13.42\n  2.734   1.355   0.446   0.112399","category":"page"},{"location":"oxygen/","page":"Oxygen atoms","title":"Oxygen atoms","text":"note: Note\nThe add_oxygens function adds oxygen atoms to the backbone using idealized geometry, and oxygens atom will on average deviate 0.05 Å from the original positions. Moreover, the last oxygen atom is also given a random orientation, as that information is lost when the backbone is reduced to 3 atoms, and there's no next nitrogen atom to compare to.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"CurrentModule = Backboner\nDocTestSetup = quote\n    using Backboner\nend","category":"page"},{"location":"#Backboner","page":"Overview","title":"Backboner","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"(Image: Latest Release) (Image: MIT license) (Image: Documentation) (Image: Documentation) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Backboner is a Julia package that offers a suite of tools for storing protein backbone atom positions, estimating oxygen atom positions, assigning secondary structure, and more. View the source code on GitHub (licensed under MIT).","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Backboner is a registered Julia package, and can be installed with the Julia package manager:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using Pkg\nPkg.add(\"Backboner\")","category":"page"},{"location":"#Usage","page":"Overview","title":"Usage","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The Protein type wraps a vector of Chains.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> using Backboner\n\njulia> protein = pdb_to_protein(\"test/data/1ZAK.pdb\")\n2-element Vector{ProteinChain}:\n ProteinChain A with 220 residues\n ProteinChain B with 220 residues\n\njulia> chain = protein[\"A\"] # chains can be accessed by name\nProteinChain A with 220 residues\n\njulia> protein[\"A\"] == protein[1] # numeric indexing also works\ntrue\n\njulia> new_protein = [protein[\"A\"]] # create a new protein with a single chain\n1-element Vector{ProteinChain}:\n ProteinChain A with 220 residues\n\njulia> protein_to_pdb(new_protein, \"test/data/1ZAK_A.pdb\");","category":"page"},{"location":"#API-Reference","page":"Overview","title":"API Reference","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Modules = [Backboner]","category":"page"},{"location":"#Backboner.Backbone","page":"Overview","title":"Backboner.Backbone","text":"Backbone{N, T <: Real} <: AbstractArray{T, 3}\n\nA wrapper for a 3xNxL array of coordinates of atoms. Backbone{4} is used to store 3-dimensional coordinates of the backbone atoms (N, CA, C, O) of a protein chain.\n\n\n\n\n\n","category":"type"},{"location":"#Backboner.ProteinChain","page":"Overview","title":"Backboner.ProteinChain","text":"ProteinChain <: AbstractVector{Residue}\n\nA chain has an identifier (usually a single letter) and holds the backbone atom coordinates, amino acid sequence, and secondary structures of a protein chain. \n\n\n\n\n\n","category":"type"},{"location":"#AssigningSecondaryStructure.assign_secondary_structure!-Tuple{Vector{ProteinChain}}","page":"Overview","title":"AssigningSecondaryStructure.assign_secondary_structure!","text":"assign_secondary_structure!(protein)\n\nUses a simplified version of DSSP to fill the secondary structure vector of each chain with '-' (coil/loop), 'H' (helix), and 'E' (strand).\n\n\n\n\n\n","category":"method"},{"location":"#AssigningSecondaryStructure.assign_secondary_structure-Tuple{Vector{ProteinChain}}","page":"Overview","title":"AssigningSecondaryStructure.assign_secondary_structure","text":"assign_secondary_structure(protein)\n\nReturns a new protein with secondary structure assigned.\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.add_oxygens-Union{Tuple{Backbone{3, T}}, Tuple{T}} where T<:Real","page":"Overview","title":"Backboner.add_oxygens","text":"add_oxygens(backbone::Backbone{3})\n\nAdd oxygen atoms to the backbone of a protein, turning the coordinate array from size 3x3xL to 3x4xL-1, where L is the length of the backbone.\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.atom_coord_matrix-Tuple{Backbone, Any}","page":"Overview","title":"Backboner.atom_coord_matrix","text":"atom_coord_matrix(backbone, i)\n\nReturns the coordinates of specific columns of atoms in a backbone.\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.atom_distances-Union{Tuple{N}, Tuple{Backbone{N}, Integer, Integer}, Tuple{Backbone{N}, Integer, Integer, Integer}} where N","page":"Overview","title":"Backboner.atom_distances","text":"atom_distances(backbone::Backbone, atom1::Integer, atom2::Integer, residue_offset::Integer)\n\nCalculate the distances between all pairs of two types atoms in a backbone, e.g. the distances between all pairs of contiguous carbonyl and nitrogen atoms. atom1 and atom2 are the indices of the atoms in the backbone, and residue_offset is the number of residues between the atoms (0 by default).\n\nReturns a vector of distances of length (length(backbone) - residue_offset).\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.backbone_to_locs_and_rots-Union{Tuple{Backbone{N, T}}, Tuple{T}, Tuple{N}, Tuple{Backbone{N, T}, Symbol}} where {N, T}","page":"Overview","title":"Backboner.backbone_to_locs_and_rots","text":"backbone_to_locs_and_rots(backbone, unit=:angstrom)\n\nReturns the locations and rotation matrices of residues in a backbone, according to a defined standard triangle (Backboner.STANDARD_TRIANGLE_ANGSTROM).\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.bonds_vecs_and_lens-Union{Tuple{Backbone{N}}, Tuple{N}} where N","page":"Overview","title":"Backboner.bonds_vecs_and_lens","text":"Returns the vectors and lengths connecting each pair of adjacent atoms in the backbone\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.carbonyl_nitrogen_distances-Tuple{Backbone}","page":"Overview","title":"Backboner.carbonyl_nitrogen_distances","text":"carbonyl_nitrogen_distances(backbone::Backbone)\n\nCalculate the distances between all pairs of contiguous carbonyl and nitrogen atoms in a backbone. Returns a vector of distances of length (length(backbone) - 1).\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.coords_from_vecs-Tuple{Any}","page":"Overview","title":"Backboner.coords_from_vecs","text":"Turns a list of vectors into a set of points starting at the origin, where p1 = 0, p2 = v1 + p1, p3 = v2 + p2, etc.\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.dihedrals2xyz-Tuple{AbstractVecOrMat, AbstractMatrix}","page":"Overview","title":"Backboner.dihedrals2xyz","text":"dihedrals2xyz(dihedrals::AbstractVecOrMat, start_res::AbstractMatrix; bond_lengths=MEAN_BOND_LENGTH, bond_angles=MEAN_BOND_ANGLE)\n\nTakes an array or a 3xN matrix of dihedrals and a starting residue and returns the xyz coordinates determined by the dihedrals, bond lengths and bond angles. \n\n\n\n\n\n","category":"method"},{"location":"#Backboner.dihedrals2xyz_exact-Tuple{AbstractVecOrMat, AbstractMatrix, AbstractVector, AbstractVector}","page":"Overview","title":"Backboner.dihedrals2xyz_exact","text":"dihedrals2xyz_exact(dihedrals::AbstractVecOrMat, start_res::AbstractMatrix, ks::AbstractVector, ls::AbstractVector)\n\nMaps dihedrals, adjacent bond lengths, skips lengths, and a starting residue to xyz coordinates. \n\n\n\n\n\n","category":"method"},{"location":"#Backboner.dihedrals_to_vecs_respect_bond_angles-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractVecOrMat}} where T","page":"Overview","title":"Backboner.dihedrals_to_vecs_respect_bond_angles","text":"Edits the dihedrals of the given coords to a list or 3xN matrix of new dihedrals.\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.fix_bond_angle-NTuple{5, Any}","page":"Overview","title":"Backboner.fix_bond_angle","text":"Fixes P3 to the correct bond angle given its bond length and skip length, while keeping it in the same plane defined by the initial P1-P2-P3.\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.fix_bond_lengths_sequence-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractVector}} where T","page":"Overview","title":"Backboner.fix_bond_lengths_sequence","text":"Fix all bond lengths in coords to the bond lengths given in l.\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.fix_sequence_lengths_angles-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractVector, AbstractVector}} where T","page":"Overview","title":"Backboner.fix_sequence_lengths_angles","text":"Fixes the coords_vector to the exact sequence of lengths and angles (angles parametrized by skip lengths \"ls\"), where ks = [NCa1, CaC1, CN1, ...] and ls = [NC, CaN, CCa, ...].\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.fix_sequence_of_points-Tuple{Any, Any, Any}","page":"Overview","title":"Backboner.fix_sequence_of_points","text":"Fix a sequence of points to their bond angles determined by ks and ls (bond lenths and skip lengths).\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.fixed_bond_lengths-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, Any, Any, Any}} where T","page":"Overview","title":"Backboner.fixed_bond_lengths","text":"Fix the bond lengths of respective bonds to NCa, CaC, and CN, and return the new coordinates.\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.get_dihedrals-Tuple{AbstractMatrix, AbstractVector}","page":"Overview","title":"Backboner.get_dihedrals","text":"get_dihedrals(vecs::AbstractMatrix, lengths::AbstractVector)\n\nGetting dihedral angles from vectors stored as a 3xN matrix and their lengths.\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.get_dihedrals-Tuple{Backbone}","page":"Overview","title":"Backboner.get_dihedrals","text":"get_dihedrals(backbone::Backbone)\n\nGetting dihedral angles from a Backbone.\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.get_ks_ls-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T","page":"Overview","title":"Backboner.get_ks_ls","text":"get_ks_ls(coords::AbstractArray{T, 3}) where T\n\nReturns the bond lengths between adjacent atoms (ks) and the skip lengths (ls).\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.get_ks_ls_dihs-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T","page":"Overview","title":"Backboner.get_ks_ls_dihs","text":"get_ks_ls_dihs(coords::AbstractArray{T, 3}) where T\n\nGets bond lengths, skip lengths, and dihedrals from coords. \n\n\n\n\n\n","category":"method"},{"location":"#Backboner.idealize_lengths_angles-Union{Tuple{AbstractVector{<:AbstractArray{T, 3}}}, Tuple{T}} where T","page":"Overview","title":"Backboner.idealize_lengths_angles","text":"idealize_lengths_angles(coords_vector::AbstractVector{<:AbstractArray{T, 3}}; bond_lengths=MEAN_BOND_LENGTH, bond_angles=MEAN_BOND_ANGLE) where T\n\nIdealizes the bond lengths and angles of coordsvector while maintaining the same overall structure. coordsvector can be a single 3x3xN matrix or a vector of 3x3xN matrices.\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.locs_and_rots_to_backbone-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractArray{T, 3}}} where T","page":"Overview","title":"Backboner.locs_and_rots_to_backbone","text":"locs_and_rots_to_backbone(locations, rot_matrices; unit=:angstrom)\n\nReturns a backbone with the given locations and rotation matrices of residues. If unit is :nm, the locations are converted to angstroms by multiplying them by 10.\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.new_frame_dihedrals-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractMatrix}} where T","page":"Overview","title":"Backboner.new_frame_dihedrals","text":"new_frame_dihedrals(frames_prev::AbstractArray{T, 4}, dihedrals::AbstractMatrix) where T\n\nTakes protxyz and a singular set of dihedrals to place the next frame with idealized bond lengths and angles\n\n\n\n\n\n","category":"method"},{"location":"#Backboner.pdb_to_protein-Tuple{String}","page":"Overview","title":"Backboner.pdb_to_protein","text":"pdb_to_protein(filename::String)\n\nAssumes that each residue starts with four atoms: N, CA, C, O.\n\n\n\n\n\n","category":"method"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/#Backbone","page":"Types","title":"Backbone","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"The Backbone type is designed to efficiently store and manipulate the three-dimensional coordinates of backbone atoms in proteins. It is a fundamental component, and is literally the backbone of protein structures.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Backbone{N, T} is a wrapper around a 3xNxL array, where:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"3 are the three spatial dimensions for the coordinates.\nN is the number of atoms in the backbone per residue.\nL is the number of residues in the backbone.\nT is the element type of the coordinate array.","category":"page"},{"location":"types/#Chain","page":"Types","title":"Chain","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"A ProteinChain represents a protein chain, and holds an identifier (usually a single letter), backbone atom coordinates, the amino acid sequence, and secondary structure information.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"id: A string identifier for the chain.\nbackbone: An instance of Backbone{4}, storing the coordinates of backbone atoms.\naavector: A vector for storing the amino acid sequence.\nssvector: A vector for storing the secondary structure.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"The ProteinChain type is designed to provide a comprehensive and consistent representation of a protein chain, ensuring that the backbone coordinates align with the corresponding amino acid sequences and secondary structures.","category":"page"}]
}
