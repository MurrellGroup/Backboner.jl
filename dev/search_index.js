var documenterSearchIndex = {"docs":
[{"location":"backboner/#Backboner-API","page":"Backboner API","title":"Backboner API","text":"","category":"section"},{"location":"backboner/","page":"Backboner API","title":"Backboner API","text":"Modules = [Backboner]","category":"page"},{"location":"backboner/#Backboner.Backbone","page":"Backboner API","title":"Backboner.Backbone","text":"Backbone{T <: Real} <: AbstractMatrix{T}\n\nThe Backbone type is designed to efficiently store and manipulate the three-dimensional coordinates of backbone atoms.\n\nExamples\n\nA Backbone can be created from a matrix of coordinates:\n\njulia> backbone = Backbone(zeros(3, 5)) # 5 atoms with 3 coordinates each\n5-element Backbone{Float64}:\n [0.0, 0.0, 0.0]\n [0.0, 0.0, 0.0]\n [0.0, 0.0, 0.0]\n [0.0, 0.0, 0.0]\n [0.0, 0.0, 0.0]\n\njulia> backbone[1] = [1.0, 2.0, 3.0]; # set the first atom's coordinates\n\njulia> backbone\n3×5 Backbone{Float64, Matrix{Float64}}:\n 1.0  0.0  0.0  0.0  0.0\n 2.0  0.0  0.0  0.0  0.0\n 3.0  0.0  0.0  0.0  0.0\n\njulia> backbone[1:2] # indexing by range returns a `Backbone` wrapped around a view of the original\n3×2 Backbone{Float64, Matrix{Float64}}:\n 1.0  0.0\n 2.0  0.0\n 3.0  0.0\n\nArrays will always be flattened to be a 3xN matrix:\n\njulia> backbone = Backbone(zeros(3, 3, 4)) # e.g. 3 coordinates per atom, 3 atoms per residue, 4 residues\n3×12 Backbone{Float64, Matrix{Float64}}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n","category":"type"},{"location":"backboner/#Backboner.ChainedBonds","page":"Backboner API","title":"Backboner.ChainedBonds","text":"ChainedBonds{T <: Real, V <: AbstractVector{T}}\n\nA lazy way to store a backbone as a series of bond lengths, angles, and dihedrals. It can be instantiated from a Backbone or a matrix of bond vectors. It can also be used to instantiate a Backbone using the Backbone(bonds::ChainedBonds) constructor.\n\nExamples\n\njulia> backbone = Protein.readpdb(\"test/data/1ZAK.pdb\")[\"A\"].backbone\n3×660 Backbone{Float32, Matrix{Float32}}:\n 22.346  22.901  23.227  24.115  24.478  25.289  26.091  26.814  …  23.137  22.572  21.48   22.041  21.808  22.263  21.085\n 17.547  18.031  16.793  16.923  15.779  14.65   14.958  13.827     13.041  14.235  14.668  14.866  13.861  13.862  14.233\n 23.294  21.993  21.163  20.175  19.336  20.009  21.056  21.652      5.676   5.844   4.974   3.569   2.734   1.355   0.446\n\njulia> bonds = ChainedBonds(backbone)\nChainedBonds{Float32, Vector{Float32}} with 659 bonds, 658 angles, and 657 dihedrals\n\n\n\n\n\n","category":"type"},{"location":"backboner/#Backboner.Frames","page":"Backboner API","title":"Backboner.Frames","text":"Frames{T <: Real} <: AbstractVector{Tuple{QuatRotation{T}, Vector{T}}}\n\nThe Frames type is designed to efficiently store and manipulate the rotation and translation of a set of frames.\n\n\n\n\n\n","category":"type"},{"location":"backboner/#Backboner.append_bonds-Tuple{Backbone, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"Backboner API","title":"Backboner.append_bonds","text":"append_bonds(backbone, lengths, angles, dihedrals)\n\n\n\n\n\n","category":"method"},{"location":"backboner/#Backboner.is_knotted-Union{Tuple{Backbone{T, M} where M<:AbstractMatrix{T}}, Tuple{T}} where T<:Real","page":"Backboner API","title":"Backboner.is_knotted","text":"is_knotted(backbone::Backbone)\n\nCheck if a backbone is knotted.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Overview","title":"Overview","text":"CurrentModule = Backboner\nDocTestSetup = quote\n    using Backboner\nend","category":"page"},{"location":"#Backboner","page":"Overview","title":"Backboner","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"(Image: Latest Release) (Image: MIT license) (Image: Documentation) (Image: Documentation) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Backboner is a Julia package that offers a suite of tools for storing protein backbone atom positions, estimating oxygen atom positions, assigning secondary structure, and more. View the source code on GitHub (licensed under MIT).","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Backboner is a registered Julia package, and can be installed with the Julia package manager:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using Pkg\nPkg.add(\"Backboner\")","category":"page"},{"location":"#Usage","page":"Overview","title":"Usage","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The Protein type wraps a vector of Chains.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> using Backboner, Backboner.Protein\n\njulia> protein = readpdb(\"test/data/1ZAK.pdb\")\n2-element Vector{Chain}:\n Chain A with 220 residues\n Chain B with 220 residues\n\njulia> chain = protein[\"A\"] # chains can be accessed by name\nChain A with 220 residues\n\njulia> protein[\"A\"] == protein[1] # numeric indexing also works\ntrue\n\njulia> new_protein = [protein[\"A\"]] # create a new protein with a single chain\n1-element Vector{Chain}:\n Chain A with 220 residues\n\njulia> writepdb(new_protein, \"test/data/1ZAK_A.pdb\");","category":"page"},{"location":"protein/#Protein-API","page":"Protein API","title":"Protein API","text":"","category":"section"},{"location":"protein/","page":"Protein API","title":"Protein API","text":"These functions need to be imported explicitly with using/import Backboner.Protein","category":"page"},{"location":"protein/","page":"Protein API","title":"Protein API","text":"Modules = [Backboner.Protein]","category":"page"},{"location":"protein/#Backboner.Protein.Chain","page":"Protein API","title":"Backboner.Protein.Chain","text":"Chain <: AbstractVector{Residue}\n\nA Chain represents a chain of a protein, and is a vector of Residues, which are instantiated from indexing the chain.\n\nFields\n\nid::AbstractString: A string identifier (usually a single letter).\nbackbone::Backbone: A backbone with a length divisible by 3, to ensure 3 atoms per residue (N, Ca, C).\nmodelnum::Int: The model number of the chain.\nresnums::Vector{Int}: storing the residue numbers.\naavector::Vector{Char}: storing the amino acid sequence.\nssvector::Vector{Char}: storing the secondary structure.\n\n\n\n\n\n","category":"type"},{"location":"protein/#Backboner.Protein.alphacarbon_angles-Tuple{Backboner.Protein.Chain}","page":"Protein API","title":"Backboner.Protein.alphacarbon_angles","text":"alphacarbon_angles(chain::Chain)\nalphacarbon_angles(bonds::ChainedBonds)\n\nCalculate the angles at the alphacarbon atoms (N-Ca-C angles) of a chains backbone, or take directly from a precalculated ChainedBonds instance.\n\n\n\n\n\n","category":"method"},{"location":"protein/#Backboner.Protein.alphacarbon_carbonyl_distances-Tuple{Backboner.Protein.Chain}","page":"Protein API","title":"Backboner.Protein.alphacarbon_carbonyl_distances","text":"alphacarbon_carbonyl_distances(chain::Chain)\nalphacarbon_carbonyl_distances(backbone::Backbone)\nalphacarbon_carbonyl_distances(bonds::ChainedBonds)\n\nCalculate the distances between all pairs of contiguous alpha-carbon and carbonyl atoms in a chain. Returns a vector of distances of length length(chain).\n\n\n\n\n\n","category":"method"},{"location":"protein/#Backboner.Protein.alphacarbon_coords-Tuple{Backboner.Protein.Chain}","page":"Protein API","title":"Backboner.Protein.alphacarbon_coords","text":"alphacarbon_coords(chain::Chain)\nalphacarbon_coords(backbone::Backbone)\n\nReturns the coordinates of all alphacarbon atoms in a chain, as a 3xN matrix.\n\n\n\n\n\n","category":"method"},{"location":"protein/#Backboner.Protein.carbonyl_angles-Tuple{Backboner.Protein.Chain}","page":"Protein API","title":"Backboner.Protein.carbonyl_angles","text":"carbonyl_angles(chain::Chain)\ncarbonyl_angles(bonds::ChainedBonds)\n\nCalculate the angles at the carbonyl atoms (Ca-C-N angles) of a chain's backbone, or take directly from a precalculated ChainedBonds instance.\n\n\n\n\n\n","category":"method"},{"location":"protein/#Backboner.Protein.carbonyl_coords-Tuple{Backboner.Protein.Chain}","page":"Protein API","title":"Backboner.Protein.carbonyl_coords","text":"carbonyl_coords(chain::Chain)\ncarbonyl_coords(backbone::Backbone)\n\nReturns the coordinates of all carbonyl atoms in a chain, as a 3xN matrix.\n\n\n\n\n\n","category":"method"},{"location":"protein/#Backboner.Protein.carbonyl_nitrogen_distances-Tuple{Backboner.Protein.Chain}","page":"Protein API","title":"Backboner.Protein.carbonyl_nitrogen_distances","text":"carbonyl_nitrogen_distances(chain::Chain)\ncarbonyl_nitrogen_distances(backbone::Backbone)\ncarbonyl_nitrogen_distances(bonds::ChainedBonds)\n\nCalculate the distances between all pairs of contiguous carbonyl and nitrogen atoms in a chain. Returns a vector of distances of length length(chain) - 1.\n\n\n\n\n\n","category":"method"},{"location":"protein/#Backboner.Protein.nitrogen_alphacarbon_distances-Tuple{Backboner.Protein.Chain}","page":"Protein API","title":"Backboner.Protein.nitrogen_alphacarbon_distances","text":"nitrogen_alphacarbon_distances(chain::Chain)\nnitrogen_alphacarbon_distances(backbone::Backbone)\nnitrogen_alphacarbon_distances(bonds::ChainedBonds)\n\nCalculate the distances between all pairs of contiguous nitrogen and alpha-carbon atoms in a chain. Returns a vector of distances of length length(chain).\n\n\n\n\n\n","category":"method"},{"location":"protein/#Backboner.Protein.nitrogen_angles-Tuple{Backboner.Protein.Chain}","page":"Protein API","title":"Backboner.Protein.nitrogen_angles","text":"nitrogen_angles(chain::Chain)\nnitrogen_angles(backbone::Backbone)\nnitrogen_angles(bonds::ChainedBonds)\n\nCalculate the angles at the nitrogen atoms (C-N-Ca angles) of a chains backbone, or take directly from a precalculated ChainedBonds instance.\n\n\n\n\n\n","category":"method"},{"location":"protein/#Backboner.Protein.nitrogen_coords-Tuple{Backboner.Protein.Chain}","page":"Protein API","title":"Backboner.Protein.nitrogen_coords","text":"nitrogen_coords(chain::Chain)\nnitrogen_coords(backbone::Backbone)\n\nReturns the coordinates of all nitrogen atoms in a chain, as a 3xN matrix.\n\n\n\n\n\n","category":"method"},{"location":"protein/#Backboner.Protein.omega_angles-Tuple{Backboner.Protein.Chain}","page":"Protein API","title":"Backboner.Protein.omega_angles","text":"omega_angles(chain::Chain)\nomega_angles(backbone::Backbone)\nomega_angles(bonds::ChainedBonds)\n\nCalculate the omega (Ω) angles of a chain's backbone, or take directly from a precalculated ChainedBonds instance.\n\n\n\n\n\n","category":"method"},{"location":"protein/#Backboner.Protein.oxygen_coords-Tuple{Backboner.Protein.Chain}","page":"Protein API","title":"Backboner.Protein.oxygen_coords","text":"oxygen_coords(chain::Chain)\noxygen_coords(backbone::Backbone)\n\nAdd oxygen atoms to the backbone of a protein, turning the coordinate array from size 3x3xL to 3x4xL-1, where L is the length of the backbone.\n\nExample\n\njulia> chains = readpdb(\"test/data/1ZAK.pdb\")\n2-element Vector{Chain}:\n Chain A with 220 residues\n Chain B with 220 residues\n\njulia> oxygen_coords(chains[\"A\"]) # returns the estimated position of oxygen atoms in chain A (~0.05 Å mean deviation)\n3×220 Matrix{Float32}:\n 22.6697  25.1719  24.7761  25.8559  …  24.7911   22.7649   22.6578   21.24\n 15.7257  13.505   13.5151  11.478      15.0888   12.2361   15.8825   14.2933\n 21.4295  19.5663  22.8638  25.3283      7.95346   4.81901   3.24164  -0.742424        \n\nnote: Note\nThe oxygen_coords function finds the oxygen atoms to the backbone using idealized geometry, and oxygens atom will on average deviate 0.05 Å from original PDB positions. Moreover, the last oxygen atom is essentially given a random (although deterministic) orientation, as that information is lost when the backbone is reduced to 3 atoms, and there's no next nitrogen atom to compare with.\n\n\n\n\n\n","category":"method"},{"location":"protein/#Backboner.Protein.phi_angles-Tuple{Backboner.Protein.Chain}","page":"Protein API","title":"Backboner.Protein.phi_angles","text":"phi_angles(chain::Chain)\nphi_angles(backbone::Backbone)\nphi_angles(bonds::ChainedBonds)\n\nCalculate the phi (φ) angles of a chain's backbone, or take directly from a precalculated ChainedBonds instance.\n\n\n\n\n\n","category":"method"},{"location":"protein/#Backboner.Protein.psi_angles-Tuple{Backboner.Protein.Chain}","page":"Protein API","title":"Backboner.Protein.psi_angles","text":"psi_angles(chain::Chain)\npsi_angles(backbone::Backbone)\npsi_angles(bonds::ChainedBonds)\n\nCalculate the psi (ψ) angles of a chain's backbone, or take directly from a precalculated ChainedBonds instance.\n\n\n\n\n\n","category":"method"},{"location":"protein/#Backboner.Protein.readpdb-Tuple{String}","page":"Protein API","title":"Backboner.Protein.readpdb","text":"readpdb(pdbfile::String)\n\nLoads a protein (represented as a Vector{Protein.Chain}) from a PDB file. Assumes that each residue starts with three atoms: N, CA, C.\n\n\n\n\n\n","category":"method"},{"location":"protein/#Backboner.Protein.writepdb","page":"Protein API","title":"Backboner.Protein.writepdb","text":"writepdb(protein::Vector{Protein.Chain}, filename)\n\nWrite a protein (represented as a Vector{Protein.Chain}s) to a PDB file.\n\n\n\n\n\n","category":"function"}]
}
